#!/bin/bash

# All scripts except bin/list-all will have access to the following env vars to act upon:
#
#     ASDF_INSTALL_TYPE - version or ref
#     ASDF_INSTALL_VERSION - if ASDF_INSTALL_TYPE is version then this will be the version number. Else it will be the git ref that is passed. Might point to a tag/commit/branch on the repo.
#     ASDF_INSTALL_PATH - the dir where the it has been installed (or should be installed in case of the bin/install script)
#
# These additional environment variables the bin/install script will also have accesss to:
#
#     ASDF_CONCURRENCY - the number of cores to use when compiling the source code. Useful for setting make -j.
#

set -euo pipefail

PLUGIN_DIR="$(cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd)"
# shellcheck source=lib/shared.sh
. "$PLUGIN_DIR/../lib/shared.sh"

CACHE_DIR=/tmp/asdf-xcode.cache
XCODERELEASES_PATH="${CACHE_DIR}/xcodereleases-data.json"
XCODERELEASES_URL="https://xcodereleases.com/data.json"
mkdir -p $CACHE_DIR

TEMP_DIR=$(/usr/bin/mktemp -dt asdf-xcode)
trap 'rm -rf ${TEMP_DIR}' EXIT

function assert_darwin() {
    [ "$(uname -s)" = Darwin ] || {
        echo "This plugin only works on macOS. Aborting."
        exit 1
    }
}

function assert_jq_installed() {
    [ -x "$(command -v jq)" ] || {
        echo "Install $(tput bold)jq$(tput sgr0) to continue. Aborting." >&2
        exit 1
    }
}

function cache_is_out_of_date() {
    [ -z "$(ls -A ${CACHE_DIR})" ] || [ "$(set -- "$(stat -f %c ${CACHE_DIR}/*)" && echo "$1")" -le $(($(date +%s) - 3600)) ]
}

function fetch_xcodereleases_data_if_needed() {
    if ! cache_is_out_of_date; then
        return 0
    fi
    curl \
        --silent \
        --location \
        --write-out "%{filename_effective}\n" \
        -o "$XCODERELEASES_PATH" \
        "$XCODERELEASES_URL"
}

function xcodereleases_json() {
    jq '.' "$XCODERELEASES_PATH"
}

function get_apple_cookie() {
    echo ""
}

function download_xcode() {
    local url="$1"
    local cookie
    cookie=$(get_apple_cookie)

    cd "$TEMP_DIR"

    curl \
        --silent \
        --location \
        --cookie "$cookie" \
        --progress-bar \
        --continue \
        --remote-name \
        "$url"
}

# Commands

# list-all prints a string with a space-separated list of versions.
#
# Note that the newest version should be listed last so it appears closer to
# the user’s prompt. This is helpful since the list-all command prints each
# version on it’s own line. If there are many versions it’s possible the early
# versions will be off screen. If versions are being pulled from releases page
# on a website it’s recommended to not sort the versions if at all possible.
function list-all() {
    assert_darwin && assert_jq_installed
    fetch_xcodereleases_data_if_needed
    xcodereleases_json | jq --raw-output '.[] | .version.build' | tac | tr '\n' ' '
}

# install installs the version, in the path mentioned in ASDF_INSTALL_PATH. The
# install script should exit with a status of 0 when the installation is
# successful. If the installation fails the script should exit with any non-zero
# exit status.
#
# If possible the script should only place files in the ASDF_INSTALL_PATH directory
# once the build and installation of the tool is deemed successful by the install
# script. asdf checks for the existence of the ASDF_INSTALL_PATH directory in order
# to determine if that version of the tool is installed. If the
# ASDF_INSTALL_PATH directory is populated at the beginning of the installation
# process other asdf commands run in other terminals during the installation may
# consider that version of the tool installed, even when it is not fully installed.
function install() {
    assert_darwin && assert_jq_installed
    fetch_xcodereleases_data_if_needed

    local download_url
    local xip_name
    local xip_path
    download_url=$(xcodereleases_json | jq --raw-output ".[] | first(select(.version.build == \"${ASDF_INSTALL_VERSION}\")) | .links.download.url")
    xip_name=$(basename "$download_url")
    xip_path="$TEMP_DIR/$xip_name"

    download_xcode "$download_url"

    local install_dir="$ASDF_INSTALL_PATH/$ASDF_INSTALL_VERSION"
    (mkdir -p "$install_dir" &&
        cd "$install_dir" &&
        xip --extract "$xip_path")

    sudo xcode-select --switch "$install_dir"

    xcodebuild -runFirstLaunch
}

# list-bin-paths list executables for the specified version of the tool. Must
# print a string with a space-separated list of dir paths that contain executables.
# The paths must be relative to the install path passed.
#
# If this script is not specified, asdf will look for the bin dir in an installation
# and create shims for those.
function list-bin-paths() {
    :
}

# exec-env sets up the env to run the binaries in the package.
function exec-env() {
    :
}

# exec-path gets the executable path for the specified version of the tool. Must
# print a string with the relative executable path. This allows the plugin to
# conditionally override the shim’s specified executable path, otherwise return
# the default path specified by the shim.
function exec-path() {
    :
}

# uninstall uninstalls a specific version of a tool.
function uninstall() {
    :
}

# list-legacy-filenames registers additional setter files for this plugin. Must
# print a string with a space-separated list of filenames.
#
# Note: This will only apply for users who have enabled the legacy_version_file
# option in their ~/.asdfrc.
function list-legacy-filenames() {
    echo ".xcode-version"
}

# parse-legacy-file can be used to further parse the legacy file found by
# asdf. If parse-legacy-file isn’t implemented, asdf will simply cat the
# file to determine the version. The script will be passed the file path
# as its first argument.
function parse-legacy-file() {
    echo ".xcode-version"
}

# Case block to handle hard links in the plugin bin directory

case $(basename "$0") in
list-all)
    list-all
    ;;
install)
    install
    ;;
list-bin-paths)
    list-bin-paths
    ;;
exec-env)
    exec-env
    ;;
exec-path)
    exec-path
    ;;
uninstall)
    uninstall
    ;;
list-legacy-filenames)
    list-legacy-filenames
    ;;
parse-legacy-file)
    parse-legacy-file
    ;;
esac
